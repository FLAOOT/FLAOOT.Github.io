<script>
// Улучшенная версия с оптимизациями
const CHUNK_SIZE = 16;
const RENDER_DISTANCE = 2; // Уменьшаем дистанцию рендеринга

class Game {
    constructor() {
        // ... предыдущий код инициализации ...

        // Оптимизация: объединенная геометрия
        this.chunkMeshes = new THREE.Group();
        scene.add(this.chunkMeshes);
    }

    generateChunk(chunkX, chunkZ) {
        const geometry = new THREE.BoxGeometry();
        const material = new THREE.MeshBasicMaterial({ vertexColors: true });
        const chunkMesh = new THREE.InstancedMesh(geometry, material, CHUNK_SIZE**3);
        
        let i = 0;
        for(let x = 0; x < CHUNK_SIZE; x++) {
            for(let z = 0; z < CHUNK_SIZE; z++) {
                const height = Math.floor(Math.random() * 16);
                for(let y = 0; y < height; y++) {
                    const matrix = new THREE.Matrix4().makeTranslation(
                        chunkX * CHUNK_SIZE + x,
                        y,
                        chunkZ * CHUNK_SIZE + z
                    );
                    chunkMesh.setMatrixAt(i++, matrix);
                    
                    // Добавляем физическое тело для блока
                    const blockBody = new CANNON.Body({
                        mass: 0, // Статичное тело
                        shape: new CANNON.Box(new CANNON.Vec3(0.5, 0.5, 0.5)),
                        position: new CANNON.Vec3(
                            chunkX * CHUNK_SIZE + x,
                            y,
                            chunkZ * CHUNK_SIZE + z
                        )
                    });
                    physicsWorld.addBody(blockBody);
                }
            }
        }
        this.chunkMeshes.add(chunkMesh);
    }

    initPlayer() {
        // Улучшенная физика игрока
        playerBody = new CANNON.Body({
            mass: 5,
            position: new CANNON.Vec3(0, 20, 0),
            shape: new CANNON.Sphere(0.4),
            material: new CANNON.Material(),
            fixedRotation: true
        });

        // Настройка трения
        playerBody.linearDamping = 0.9;
        physicsWorld.addBody(playerBody);

        // Коллизия с землей
        const groundMaterial = new CANNON.Material();
        const playerGroundContact = new CANNON.ContactMaterial(
            playerBody.material,
            groundMaterial,
            {
                friction: 0.5,
                restitution: 0
            }
        );
        physicsWorld.addContactMaterial(playerGroundContact);
    }

    initControls() {
        // Улучшенное управление с применением сил
        const moveForce = 20;
        const jumpForce = 8;

        window.addEventListener('keydown', (e) => {
            if(e.code === 'Space' && this.isGrounded()) {
                playerBody.velocity.y = jumpForce;
            }
        });

        const updateMovement = () => {
            if(!this.controlsEnabled) return;

            const direction = new THREE.Vector3();
            const rotation = camera.rotation.y;

            if(keys['KeyW']) direction.z -= Math.cos(rotation) * moveForce;
            if(keys['KeyS']) direction.z += Math.cos(rotation) * moveForce;
            if(keys['KeyA']) direction.x -= Math.sin(rotation) * moveForce;
            if(keys['KeyD']) direction.x += Math.sin(rotation) * moveForce;

            playerBody.velocity.x = direction.x;
            playerBody.velocity.z = direction.z;
        };

        setInterval(updateMovement, 1000/60);
    }

    isGrounded() {
        // Проверка коллизии с землей
        const result = physicsWorld.rayTestAll(
            playerBody.position,
            new CANNON.Vec3(
                playerBody.position.x,
                playerBody.position.y - 1.1,
                playerBody.position.z
            )
        );
        return result.length > 0;
    }
}

// Запуск улучшенной версии
window.addEventListener('DOMContentLoaded', () => {
    new Game();
});
</script>
