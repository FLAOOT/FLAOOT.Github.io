<!DOCTYPE html>
<html>
<head>
    <title>TeleCraft</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        }
        #info {
            position: absolute;
            top: 10px;
            left: 10px;
            color: #ffffff;
            background: rgba(32, 32, 32, 0.8);
            padding: 8px;
            border-radius: 8px;
            backdrop-filter: blur(5px);
        }
        #hotbar {
            position: absolute;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 8px;
            background: rgba(32, 32, 32, 0.8);
            padding: 8px;
            border-radius: 12px;
            backdrop-filter: blur(5px);
        }
        .block-slot {
            width: 40px;
            height: 40px;
            border: 2px solid #3390ec;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .block-slot.selected {
            border-color: #ffffff;
            background: rgba(255, 255, 255, 0.1);
        }
    </style>
</head>
<body>
    <div id="info">FPS: <span id="fps">0</span><br>Selected: <span id="selected-block">Grass</span></div>
    <div id="hotbar"></div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let camera, scene, renderer, raycaster;
        let move = { forward: 0, backward: 0, left: 0, right: 0 };
        let velocityY = 0;
        let selectedBlock = 1;
        let blocks = [];
        let lastTime = Date.now();

        const BLOCK_TYPES = {
            0: { name: 'Air', color: null },
            1: { name: 'Grass', color: '#4CAF50' },
            2: { name: 'Dirt', color: '#795548' },
            3: { name: 'Stone', color: '#9E9E9E' }
        };

        function init() {
            // Scene setup
            scene = new THREE.Scene();
            scene.background = new THREE.Color('#18222d');

            // Renderer
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Camera
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.set(10, 10, 10);
            camera.lookAt(0, 0, 0);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(1, 1, 1);
            scene.add(directionalLight);

            // Generate world
            generateWorld(16, 4, 16);

            // Controls
            document.addEventListener('keydown', onKeyDown);
            document.addEventListener('keyup', onKeyUp);
            document.addEventListener('mousedown', onMouseDown);
            document.addEventListener('mousemove', onMouseMove);
            document.body.addEventListener('click', () => {
                document.body.requestPointerLock();
            });

            // Hotbar
            initHotbar();

            // Raycaster
            raycaster = new THREE.Raycaster();

            animate();
        }

        function generateWorld(width, height, depth) {
            for (let x = 0; x < width; x++) {
                for (let z = 0; z < depth; z++) {
                    for (let y = 0; y < height; y++) {
                        const type = y === height - 1 ? 1 : y >= height - 3 ? 2 : 3;
                        addBlock(x, y, z, type);
                    }
                }
            }
        }

        function addBlock(x, y, z, type) {
            if (BLOCK_TYPES[type].color) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshPhongMaterial({ 
                    color: BLOCK_TYPES[type].color,
                    flatShading: true
                });
                const cube = new THREE.Mesh(geometry, material);
                cube.position.set(x, y, z);
                cube.userData = { type, x, y, z };
                scene.add(cube);
                blocks.push(cube);
                return cube;
            }
            return null;
        }

        function removeBlock(block) {
            scene.remove(block);
            blocks.splice(blocks.indexOf(block), 1);
        }

        function onKeyDown(event) {
            switch(event.key.toLowerCase()) {
                case 'w': move.forward = 1; break;
                case 's': move.backward = 1; break;
                case 'a': move.left = 1; break;
                case 'd': move.right = 1; break;
                case ' ': if(velocityY === 0) velocityY = 0.1; break;
            }
        }

        function onKeyUp(event) {
            switch(event.key.toLowerCase()) {
                case 'w': move.forward = 0; break;
                case 's': move.backward = 0; break;
                case 'a': move.left = 0; break;
                case 'd': move.right = 0; break;
            }
        }

        function onMouseDown(event) {
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            const intersects = raycaster.intersectObjects(blocks);
            
            if (intersects.length > 0) {
                const intersect = intersects[0];
                if (event.button === 0) { // Left click - destroy
                    removeBlock(intersect.object);
                } else if (event.button === 2) { // Right click - build
                    const normal = intersect.face.normal;
                    const newPos = intersect.object.position.clone()
                        .add(normal.multiplyScalar(1));
                    addBlock(newPos.x, newPos.y, newPos.z, selectedBlock);
                }
            }
        }

        function onMouseMove(event) {
            if (document.pointerLockElement === document.body) {
                camera.rotation.y -= event.movementX * 0.002;
                camera.rotation.x -= event.movementY * 0.002;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, camera.rotation.x));
            }
        }

        function initHotbar() {
            const hotbar = document.getElementById('hotbar');
            Object.entries(BLOCK_TYPES).forEach(([id, block]) => {
                if (id === '0') return;
                const slot = document.createElement('div');
                slot.className = `block-slot ${id === '1' ? 'selected' : ''}`;
                slot.style.backgroundColor = block.color;
                slot.onclick = () => {
                    document.querySelectorAll('.block-slot').forEach(s => s.classList.remove('selected'));
                    slot.classList.add('selected');
                    selectedBlock = parseInt(id);
                    document.getElementById('selected-block').textContent = block.name;
                };
                hotbar.appendChild(slot);
            });
        }

        function animate() {
            const now = Date.now();
            const delta = (now - lastTime) / 1000;
            lastTime = now;

            // Movement
            const speed = 5 * delta;
            const direction = new THREE.Vector3(
                move.right - move.left,
                0,
                move.backward - move.forward
            ).normalize();
            
            direction.applyEuler(camera.rotation);
            camera.position.add(direction.multiplyScalar(speed));

            // Gravity
            velocityY -= 0.02 * delta;
            camera.position.y += velocityY;
            
            // Ground collision
            if (camera.position.y < 1) {
                camera.position.y = 1;
                velocityY = 0;
            }

            // Update FPS counter
            document.getElementById('fps').textContent = Math.floor(1 / delta);

            renderer.render(scene, camera);
            requestAnimationFrame(animate);
        }

        init();
        window.onresize = () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        };
    </script>
</body>
</html>
