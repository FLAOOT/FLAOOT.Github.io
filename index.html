<!DOCTYPE html>
<html>
<head>
    <title>WebCraft Full</title>
    <style>
        /* Telegram-like —Å—Ç–∏–ª–∏ */
        :root {
            --tg-bg: #18222d;
            --tg-secondary: #2a3b4d;
            --tg-text: #ffffff;
        }

        body {
            margin: 0;
            overflow: hidden;
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: var(--tg-bg);
            color: var(--tg-text);
        }

        #ui {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(32, 44, 51, 0.9);
            padding: 15px;
            border-radius: 10px;
        }

        .tg-button {
            background: #2aabee;
            border: none;
            color: white;
            padding: 8px 15px;
            border-radius: 5px;
            margin: 5px;
            cursor: pointer;
        }

        #chat {
            position: fixed;
            bottom: 20px;
            left: 20px;
            width: 300px;
            background: rgba(32, 44, 51, 0.9);
            border-radius: 10px;
            padding: 10px;
        }
    </style>
</head>
<body>
    <div id="ui">
        <button class="tg-button" id="inventoryBtn">üéí –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</button>
        <button class="tg-button" id="chatBtn">üí¨ –ß–∞—Ç</button>
        <div>–ë–ª–æ–∫: <span id="currentBlock">grass</span></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/cannon.js/0.6.2/cannon.min.js"></script>

    <script>
        // –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è –∏–≥—Ä—ã
        const CHUNK_SIZE = 16;
        const RENDER_DISTANCE = 4;
        const BLOCK_TYPES = {
            grass: { color: 0x00ff00 },
            dirt: { color: 0x8b4513 },
            stone: { color: 0x808080 }
        };

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —Å–∏—Å—Ç–µ–º—ã
        let scene, camera, renderer, physicsWorld;
        let chunks = new Map();
        let currentBlock = 'grass';
        let playerBody;

        class Game {
            constructor() {
                this.initThreeJS();
                this.initPhysics();
                this.initWorld();
                this.initPlayer();
                this.initUI();
                this.startGameLoop();
            }

            initThreeJS() {
                scene = new THREE.Scene();
                camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
                renderer = new THREE.WebGLRenderer();
                renderer.setSize(window.innerWidth, window.innerHeight);
                document.body.appendChild(renderer.domElement);
            }

            initPhysics() {
                physicsWorld = new CANNON.World();
                physicsWorld.gravity.set(0, -9.82, 0);
            }

            initWorld() {
                for(let x = -RENDER_DISTANCE; x <= RENDER_DISTANCE; x++) {
                    for(let z = -RENDER_DISTANCE; z <= RENDER_DISTANCE; z++) {
                        this.generateChunk(x, z);
                    }
                }
            }

            generateChunk(chunkX, chunkZ) {
                const chunkKey = `${chunkX}|${chunkZ}`;
                const blocks = [];
                
                for(let x = 0; x < CHUNK_SIZE; x++) {
                    for(let z = 0; z < CHUNK_SIZE; z++) {
                        const height = Math.floor(Math.random() * 16);
                        for(let y = 0; y < height; y++) {
                            blocks.push({
                                x: chunkX * CHUNK_SIZE + x,
                                y,
                                z: chunkZ * CHUNK_SIZE + z,
                                type: y === height - 1 ? 'grass' : 'dirt'
                            });
                        }
                    }
                }
                
                chunks.set(chunkKey, blocks);
                this.renderChunk(blocks);
            }

            renderChunk(blocks) {
                blocks.forEach(block => {
                    const geometry = new THREE.BoxGeometry(1, 1, 1);
                    const material = new THREE.MeshBasicMaterial({ 
                        color: BLOCK_TYPES[block.type].color 
                    });
                    const mesh = new THREE.Mesh(geometry, material);
                    mesh.position.set(block.x, block.y, block.z);
                    scene.add(mesh);
                });
            }

            initPlayer() {
                // –§–∏–∑–∏—á–µ—Å–∫–æ–µ —Ç–µ–ª–æ
                playerBody = new CANNON.Body({
                    mass: 5,
                    position: new CANNON.Vec3(0, 20, 0),
                    shape: new CANNON.Sphere(0.5)
                });
                physicsWorld.addBody(playerBody);

                // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ
                this.initControls();
            }

            initControls() {
                const keys = {};
                document.addEventListener('keydown', e => keys[e.key] = true);
                document.addEventListener('keyup', e => keys[e.key] = false);

                const velocity = 5;
                const animate = () => {
                    if(keys['w']) playerBody.position.z -= velocity * 0.1;
                    if(keys['s']) playerBody.position.z += velocity * 0.1;
                    if(keys['a']) playerBody.position.x -= velocity * 0.1;
                    if(keys['d']) playerBody.position.x += velocity * 0.1;
                    requestAnimationFrame(animate);
                };
                animate();

                // –í–∑–∞–∏–º–æ–¥–µ–π—Å—Ç–≤–∏–µ —Å –±–ª–æ–∫–∞–º–∏
                document.addEventListener('mousedown', e => {
                    const raycaster = new THREE.Raycaster();
                    const mouse = new THREE.Vector2();
                    mouse.x = (e.clientX / window.innerWidth) * 2 - 1;
                    mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
                    
                    raycaster.setFromCamera(mouse, camera);
                    const intersects = raycaster.intersectObjects(scene.children);
                    
                    if(intersects.length > 0) {
                        const block = intersects[0].object;
                        if(e.button === 0) this.removeBlock(block);
                        if(e.button === 2) this.placeBlock(block.position);
                    }
                });
            }

            removeBlock(block) {
                scene.remove(block);
            }

            placeBlock(pos) {
                const geometry = new THREE.BoxGeometry(1, 1, 1);
                const material = new THREE.MeshBasicMaterial({ 
                    color: BLOCK_TYPES[currentBlock].color 
                });
                const newBlock = new THREE.Mesh(geometry, material);
                newBlock.position.copy(pos).add(new THREE.Vector3(0, 1, 0));
                scene.add(newBlock);
            }

            initUI() {
                document.getElementById('inventoryBtn').addEventListener('click', () => {
                    this.toggleInventory();
                });

                document.getElementById('chatBtn').addEventListener('click', () => {
                    this.toggleChat();
                });
            }

            toggleInventory() {
                // –õ–æ–≥–∏–∫–∞ –∏–Ω–≤–µ–Ω—Ç–∞—Ä—è
                console.log('Inventory toggle');
            }

            toggleChat() {
                // –õ–æ–≥–∏–∫–∞ —á–∞—Ç–∞
                console.log('Chat toggle');
            }

            startGameLoop() {
                const animate = () => {
                    requestAnimationFrame(animate);
                    physicsWorld.step(1/60);
                    camera.position.copy(playerBody.position);
                    camera.position.y += 1; // –í—ã—Å–æ—Ç–∞ –æ—Ç –ø–µ—Ä–≤–æ–≥–æ –ª–∏—Ü–∞
                    renderer.render(scene, camera);
                };
                animate();
            }
        }

        // –ó–∞–ø—É—Å–∫ –∏–≥—Ä—ã
        window.addEventListener('DOMContentLoaded', () => {
            new Game();
        });

        // –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
