<!DOCTYPE html>
<html>
<head>
    <title>TelegramCraft</title>
    <style>
        /* ... (предыдущие стили остаются без изменений) ... */
        
        #inventory {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255,255,255,0.95);
            padding: 12px;
            border-radius: 14px;
            display: none;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
            backdrop-filter: blur(4px);
            z-index: 500;
            flex-wrap: wrap;
            max-width: 400px;
        }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Остальная разметка остается без изменений -->
    
    <script>
        // ... (предыдущие настройки и переменные) ...

        const BLOCK_TYPES = {
            grass: { color: 0x8BC34A, name: 'Трава' },
            dirt: { color: 0x795548, name: 'Земля' },
            stone: { color: 0x9E9E9E, name: 'Камень' },
            wood: { color: 0x8B5A2B, name: 'Дерево' },
            glass: { color: 0x80DEEA, name: 'Стекло' }
        };

        let inventory = {
            slots: {
                0: { type: 'grass', count: 64 },
                1: { type: 'dirt', count: 64 },
                2: { type: 'stone', count: 64 },
                3: { type: 'wood', count: 64 },
                4: { type: 'glass', count: 64 }
            },
            selected: 0
        };

        function initInventory() {
            const inventoryElement = document.getElementById('inventory');
            inventoryElement.innerHTML = '';
            
            Object.entries(inventory.slots).forEach(([slot, data]) => {
                const slotElement = document.createElement('div');
                slotElement.className = `slot ${slot == inventory.selected ? 'active' : ''}`;
                slotElement.style.backgroundColor = `#${new THREE.Color(BLOCK_TYPES[data.type].color).getHexString()}`;
                
                const countElement = document.createElement('div');
                countElement.className = 'slot-count';
                countElement.textContent = data.count;
                
                const nameElement = document.createElement('div');
                nameElement.className = 'slot-name';
                nameElement.textContent = BLOCK_TYPES[data.type].name;
                
                slotElement.append(nameElement, countElement);
                slotElement.onclick = () => selectSlot(parseInt(slot));
                inventoryElement.appendChild(slotElement);
            });
        }

        function selectSlot(slotIndex) {
            inventory.selected = slotIndex;
            currentBlockType = inventory.slots[slotIndex].type;
            initInventory();
        }

        function checkCollisions() {
            if(creativeMode) return;

            const collisionDistance = 0.3;
            const directions = [
                { axis: 'x', sign: 1 },
                { axis: 'x', sign: -1 },
                { axis: 'z', sign: 1 },
                { axis: 'z', sign: -1 },
                { axis: 'y', sign: 1 },
                { axis: 'y', sign: -1 }
            ];

            player.onGround = false;
            
            directions.forEach(dir => {
                const testPos = player.position.clone();
                testPos[dir.axis] += dir.sign * collisionDistance;
                
                const playerBox = new THREE.Box3()
                    .setFromCenterAndSize(
                        testPos,
                        new THREE.Vector3(
                            dir.axis === 'x' ? 0.1 : player.radius*2,
                            player.height,
                            dir.axis === 'z' ? 0.1 : player.radius*2
                        )
                    );

                blocks.forEach(block => {
                    const blockBox = new THREE.Box3().setFromObject(block);
                    if(playerBox.intersectsBox(blockBox)) {
                        const overlap = blockBox.max[dir.axis] - playerBox.min[dir.axis];
                        
                        if(dir.sign === 1) {
                            player.position[dir.axis] -= overlap;
                            if(dir.axis === 'y') {
                                player.velocity.y = 0;
                                player.onGround = true;
                            }
                        } else {
                            player.position[dir.axis] += overlap;
                        }
                    }
                });
            });
        }

        function onMouseDown(e) {
            if(!document.pointerLockElement) return;

            raycaster.setFromCamera(
                new THREE.Vector2(0, 0), 
                camera
            );
            
            const intersects = raycaster.intersectObjects(scene.children);
            if(intersects.length === 0) return;

            const intersect = intersects[0];
            const blockPos = intersect.object.position;
            const normal = intersect.face.normal;

            if(e.button === 0) { // ЛКМ - разрушение
                removeBlock(blockPos.x, blockPos.y, blockPos.z);
            } 
            else if(e.button === 2) { // ПКМ - установка
                const newPos = blockPos.clone().add(normal);
                if(inventory.slots[inventory.selected].count > 0) {
                    addBlock(newPos.x, newPos.y, newPos.z, currentBlockType);
                    inventory.slots[inventory.selected].count--;
                    initInventory();
                }
            }
        }

        function toggleInventory() {
            const inv = document.getElementById('inventory');
            inv.style.display = inv.style.display === 'none' ? 'flex' : 'none';
        }

        // В обработчики событий добавить:
        document.addEventListener('keydown', e => {
            if(e.key === 'e') toggleInventory();
            if(e.key >= '1' && e.key <= '5') selectSlot(parseInt(e.key) - 1);
        });

        // Обновленная функция addBlock:
        function addBlock(x, y, z, type) {
            x = Math.round(x);
            y = Math.round(y);
            z = Math.round(z);
            
            const key = `${x},${y},${z}`;
            if(blocks.has(key)) return;

            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const material = new THREE.MeshPhongMaterial({ 
                color: BLOCK_TYPES[type].color,
                transparent: type === 'glass',
                opacity: type === 'glass' ? 0.8 : 1
            });
            
            const cube = new THREE.Mesh(geometry, material);
            cube.position.set(x, y, z);
            scene.add(cube);
            blocks.set(key, cube);
        }

        // Остальной код остается как в предыдущей версии
    </script>
</body>
</html>
