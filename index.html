<!DOCTYPE html>
<html>
<head>
    <title>Web Minecraft</title>
    <style>
        body { margin: 0; overflow: hidden; }
        #hud {
            position: fixed;
            bottom: 20px;
            width: 100%;
            display: flex;
            justify-content: center;
            gap: 10px;
            z-index: 100;
        }
        .slot {
            width: 64px;
            height: 64px;
            border: 2px solid #555;
            background: rgba(0,0,0,0.7);
            background-size: cover;
            display: flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 20px;
        }
        .active { border-color: gold; }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
        }
        #crafting {
            position: fixed;
            top: 20px;
            right: 20px;
            background: rgba(0,0,0,0.8);
            padding: 15px;
            border-radius: 5px;
            display: none;
            color: white;
        }
    </style>
</head>
<body>
    <div id="hud"></div>
    <div id="crosshair">+</div>
    <div id="crafting">
        <h3>Crafting</h3>
        <div class="craft-grid"></div>
        <div class="result-slot"></div>
    </div>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/PointerLockControls.js"></script>
    <script>
        let scene, camera, renderer, controls;
        let blocks = new Map();
        let inventory = Array(9).fill(null);
        let currentBlockType = 'dirt';
        const BLOCK_SIZE = 1;
        const MOVEMENT_SPEED = 0.1;
        const MOUSE_SENSITIVITY = 0.002;
        let moveState = { forward: false, backward: false, left: false, right: false };

        // Материалы блоков
        const materials = {
            dirt: new THREE.MeshStandardMaterial({ color: 0x8B4513 }),
            grass: new THREE.MeshStandardMaterial({ color: 0x00FF00 }),
            stone: new THREE.MeshStandardMaterial({ color: 0x808080 }),
            wood: new THREE.MeshStandardMaterial({ color: 0x8B5A2B }),
            plank: new THREE.MeshStandardMaterial({ color: 0xDEB887 })
        };

        // Рецепты крафта
        const recipes = [
            {
                input: ['wood', 'wood', null, 'wood'],
                output: { type: 'plank', count: 4 }
            }
        ];

        async function init() {
            // Инициализация сцены
            scene = new THREE.Scene();
            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            // Освещение
            const light = new THREE.DirectionalLight(0xffffff, 1);
            light.position.set(100, 100, 100);
            scene.add(light);
            scene.add(new THREE.AmbientLight(0x404040));

            // Генерация мира
            generateWorld();
            loadSave();

            // Управление
            setupControls();
            updateInventory();
            animate();
        }

        function generateWorld() {
            // Создание платформы 16x16
            for(let x = -8; x < 8; x++) {
                for(let z = -8; z < 8; z++) {
                    addBlock(x, -1, z, 'grass');
                    addBlock(x, -2, z, 'dirt');
                }
            }
        }

        function addBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if(blocks.has(key)) return;

            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const cube = new THREE.Mesh(geometry, materials[type]);
            cube.position.set(x, y, z);
            scene.add(cube);
            
            blocks.set(key, { type, mesh: cube });
        }

        function removeBlock(x, y, z) {
            const key = `${x},${y},${z}`;
            if(!blocks.has(key)) return;

            const block = blocks.get(key);
            scene.remove(block.mesh);
            blocks.delete(key);
            addToInventory(block.type);
        }

        function addToInventory(type, count = 1) {
            const slot = inventory.findIndex(s => s?.type === type);
            if(slot > -1) {
                inventory[slot].count += count;
            } else {
                const emptySlot = inventory.findIndex(s => !s);
                if(emptySlot > -1) {
                    inventory[emptySlot] = { type, count };
                }
            }
            updateInventory();
        }

        function updateInventory() {
            const hud = document.getElementById('hud');
            hud.innerHTML = '';
            inventory.forEach((item, index) => {
                const slot = document.createElement('div');
                slot.className = `slot ${index === 0 ? 'active' : ''}`;
                if(item) {
                    slot.style.backgroundColor = materials[item.type].color.getStyle();
                    slot.innerHTML = `<div>${item.count}</div>`;
                }
                slot.addEventListener('click', () => selectSlot(index));
                hud.appendChild(slot);
            });
        }

        function selectSlot(index) {
            currentBlockType = inventory[index]?.type;
            document.querySelectorAll('.slot').forEach(s => s.classList.remove('active'));
            document.querySelectorAll('.slot')[index].classList.add('active');
        }

        function setupControls() {
            controls = new THREE.PointerLockControls(camera, document.body);
            scene.add(controls.getObject());
            camera.position.set(0, 5, 0);

            document.addEventListener('keydown', e => {
                if(e.key === 'e') document.getElementById('crafting').style.display = 'block';
                if(e.key === 'Escape') document.getElementById('crafting').style.display = 'none';
                handleKeyDown(e);
            });
            
            document.addEventListener('keyup', handleKeyUp);
            document.addEventListener('mousedown', handleMouseClick);
            document.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('resize', onWindowResize);
        }

        function handleKeyDown(e) {
            switch(e.key.toLowerCase()) {
                case 'w': moveState.forward = true; break;
                case 's': moveState.backward = true; break;
                case 'a': moveState.left = true; break;
                case 'd': moveState.right = true; break;
            }
        }

        function handleKeyUp(e) {
            switch(e.key.toLowerCase()) {
                case 'w': moveState.forward = false; break;
                case 's': moveState.backward = false; break;
                case 'a': moveState.left = false; break;
                case 'd': moveState.right = false; break;
            }
        }

        function handleMouseClick(e) {
            const raycaster = new THREE.Raycaster();
            raycaster.setFromCamera(new THREE.Vector2(), camera);
            
            const intersects = raycaster.intersectObjects(scene.children);
            if(intersects.length > 0) {
                const intersect = intersects[0];
                const pos = intersect.object.position;
                
                if(e.button === 0) {
                    removeBlock(pos.x, pos.y, pos.z);
                } else if(e.button === 2 && inventory.some(s => s?.type === currentBlockType)) {
                    const normal = intersect.face.normal;
                    const newPos = pos.clone().add(normal.multiplyScalar(BLOCK_SIZE));
                    addBlock(
                        Math.round(newPos.x),
                        Math.round(newPos.y),
                        Math.round(newPos.z),
                        currentBlockType
                    );
                    inventory.find(s => s?.type === currentBlockType).count--;
                    updateInventory();
                }
            }
        }

        function handleMouseMove(e) {
            if(controls.isLocked) {
                camera.rotation.y -= e.movementX * MOUSE_SENSITIVITY;
                camera.rotation.x = Math.max(-Math.PI/2, Math.min(Math.PI/2, 
                    camera.rotation.x - e.movementY * MOUSE_SENSITIVITY));
            }
        }

        function updatePlayerPosition() {
            const direction = new THREE.Vector3();
            const rotation = camera.rotation.y;

            if(moveState.forward) direction.z -= Math.cos(rotation);
            if(moveState.backward) direction.z += Math.cos(rotation);
            if(moveState.left) direction.x -= Math.sin(rotation);
            if(moveState.right) direction.x += Math.sin(rotation);

            direction.normalize();
            controls.moveRight(direction.x * MOVEMENT_SPEED);
            controls.moveForward(-direction.z * MOVEMENT_SPEED);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            if(controls.isLocked) updatePlayerPosition();
            renderer.render(scene, camera);
        }

        // Старт игры
        init();
        document.addEventListener('contextmenu', e => e.preventDefault());
    </script>
</body>
</html>
