<!DOCTYPE html>
<html>
<head>
    <title>TelegramCraft</title>
    <style>
        /* –í—Å–µ –ø—Ä–µ–¥—ã–¥—É—â–∏–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
        body { 
            margin: 0; 
            overflow: hidden; 
            font-family: 'Roboto', sans-serif;
            background: #f3f4f5;
        }
        
        #menu {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: white;
            width: 320px;
            border-radius: 14px;
            box-shadow: 0 12px 24px rgba(0,0,0,0.1);
            padding: 24px;
            text-align: center;
            z-index: 1000;
        }
        
        .menu-title {
            color: #0088cc;
            font-size: 24px;
            margin-bottom: 24px;
            font-weight: 500;
        }
        
        .tg-button {
            display: block;
            width: 100%;
            padding: 14px;
            margin: 8px 0;
            background: #0088cc;
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 16px;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        /* –û—Å—Ç–∞–ª—å–Ω—ã–µ —Å—Ç–∏–ª–∏ –æ—Å—Ç–∞—é—Ç—Å—è –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π */
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Roboto:wght@400;500&display=swap" rel="stylesheet">
</head>
<body>
    <div id="menu">
        <div class="menu-title">TelegramCraft</div>
        <button class="tg-button" onclick="startGame('creative')">üéÆ –ù–∞—á–∞—Ç—å –∏–≥—Ä—É (–ö—Ä–µ–∞—Ç–∏–≤)</button>
        <button class="tg-button" style="background: #20c997" onclick="startGame('survival')">üåø –†–µ–∂–∏–º –≤—ã–∂–∏–≤–∞–Ω–∏—è</button>
    </div>

    <div id="hud">
        <button class="hud-button" onclick="toggleInventory()">üéí –ò–Ω–≤–µ–Ω—Ç–∞—Ä—å</button>
    </div>

    <div id="crosshair">+</div>
    <div id="inventory"></div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
        let scene, camera, renderer, raycaster;
        let keys = {};
        let currentBlockType = 'grass';
        let creativeMode = true;
        const BLOCK_SIZE = 1;
        const WORLD_SIZE = 50;
        let blocks = new Map();
        
        // –ù–∞—Å—Ç—Ä–æ–π–∫–∏ –∏–≥—Ä–æ–∫–∞
        let player = {
            position: new THREE.Vector3(0, 10, 0),
            velocity: new THREE.Vector3(),
            direction: new THREE.Vector3(),
            yaw: Math.PI,
            pitch: 0,
            height: 1.8,
            radius: 0.3,
            onGround: false
        };

        // –ü–∞—Ä–∞–º–µ—Ç—Ä—ã —Ñ–∏–∑–∏–∫–∏
        const PHYSICS = {
            gravity: 30,
            jumpForce: 8,
            moveSpeed: 5,
            flySpeed: 10,
            airControl: 0.2
        };

        const blockMaterials = {
            grass: new THREE.MeshPhongMaterial({ color: 0x8BC34A }),
            dirt: new THREE.MeshPhongMaterial({ color: 0x795548 })
        };

        function startGame(mode) {
            creativeMode = mode === 'creative';
            document.getElementById('menu').style.display = 'none';
            document.getElementById('hud').style.display = 'flex';
            initGame();
        }

        function initGame() {
            // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è Three.js
            scene = new THREE.Scene();
            scene.background = new THREE.Color(0xf3f4f5);

            renderer = new THREE.WebGLRenderer({ antialias: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            document.body.appendChild(renderer.domElement);

            camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
            
            // –û—Å–≤–µ—â–µ–Ω–∏–µ
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
            scene.add(ambientLight);
            
            const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
            directionalLight.position.set(100, 100, 100);
            scene.add(directionalLight);

            // –°–æ–∑–¥–∞–Ω–∏–µ –ø–ª–∞—Ç—Ñ–æ—Ä–º—ã
            createPlatform();
            initEventListeners();
            animate();
        }

        function createPlatform() {
            for(let x = -WORLD_SIZE/2; x <= WORLD_SIZE/2; x++) {
                for(let z = -WORLD_SIZE/2; z <= WORLD_SIZE/2; z++) {
                    addBlock(x, 0, z, 'grass');
                }
            }
        }

        function addBlock(x, y, z, type) {
            const key = `${x},${y},${z}`;
            if(blocks.has(key)) return;

            const geometry = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
            const cube = new THREE.Mesh(geometry, blockMaterials[type]);
            cube.position.set(x, y, z);
            scene.add(cube);
            blocks.set(key, cube);
        }

        function initEventListeners() {
            document.addEventListener('click', () => document.body.requestPointerLock());
            document.addEventListener('mousemove', onMouseMove);
            document.addEventListener('keydown', e => keys[e.key.toLowerCase()] = true);
            document.addEventListener('keyup', e => keys[e.key.toLowerCase()] = false);
            window.addEventListener('resize', onWindowResize);
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function onMouseMove(e) {
            if(document.pointerLockElement === document.body) {
                player.yaw -= e.movementX * 0.002;
                player.pitch = THREE.MathUtils.clamp(
                    player.pitch - e.movementY * 0.002,
                    -Math.PI/2,
                    Math.PI/2
                );
                camera.rotation.set(player.pitch, player.yaw, 0, 'YXZ');
            }
        }

        function updatePlayer(delta) {
            // –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ –¥–≤–∏–∂–µ–Ω–∏–µ–º
            const moveVector = new THREE.Vector3();
            
            if(keys['w']) moveVector.z -= 1;
            if(keys['s']) moveVector.z += 1;
            if(keys['a']) moveVector.x -= 1;
            if(keys['d']) moveVector.x += 1;
            
            if(creativeMode) {
                if(keys[' ']) moveVector.y += 1;
                if(keys['shift']) moveVector.y -= 1;
            }

            moveVector.normalize();
            const speed = creativeMode ? PHYSICS.flySpeed : PHYSICS.moveSpeed;
            moveVector.multiplyScalar(speed * delta);

            // –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –≤—Ä–∞—â–µ–Ω–∏—è
            const rotation = new THREE.Euler(0, player.yaw, 0, 'YXZ');
            moveVector.applyEuler(rotation);
            
            // –ì—Ä–∞–≤–∏—Ç–∞—Ü–∏—è –∏ –ø—Ä—ã–∂–∫–∏
            if(!creativeMode) {
                player.velocity.y -= PHYSICS.gravity * delta;
                moveVector.multiplyScalar(player.onGround ? 1 : PHYSICS.airControl);
                
                if(keys[' '] && player.onGround) {
                    player.velocity.y = PHYSICS.jumpForce;
                    player.onGround = false;
                }
            }

            player.position.add(moveVector);
            player.position.add(player.velocity.clone().multiplyScalar(delta));
            
            // –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ–ª–ª–∏–∑–∏–π
            checkCollisions();
            
            // –û–±–Ω–æ–≤–ª–µ–Ω–∏–µ –ø–æ–∑–∏—Ü–∏–∏ –∫–∞–º–µ—Ä—ã
            camera.position.copy(player.position);
        }

        function checkCollisions() {
            if(creativeMode) return;

            const playerBox = new THREE.Box3(
                new THREE.Vector3(
                    player.position.x - player.radius,
                    player.position.y,
                    player.position.z - player.radius
                ),
                new THREE.Vector3(
                    player.position.x + player.radius,
                    player.position.y + player.height,
                    player.position.z + player.radius
                )
            );

            player.onGround = false;
            
            blocks.forEach(block => {
                const blockBox = new THREE.Box3().setFromObject(block);
                if(playerBox.intersectsBox(blockBox)) {
                    const overlap = playerBox.intersect(blockBox).getSize(new THREE.Vector3());
                    
                    if(overlap.y > overlap.x && overlap.y > overlap.z) {
                        player.velocity.y = 0;
                        if(playerBox.min.y < blockBox.max.y) {
                            player.position.y = blockBox.max.y;
                            player.onGround = true;
                        }
                    }
                }
            });
        }

        function animate() {
            requestAnimationFrame(animate);
            const delta = Math.min(0.05, clock.getDelta());
            
            if(document.pointerLockElement === document.body) {
                updatePlayer(delta);
            }

            renderer.render(scene, camera);
        }

        // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è —á–∞—Å–æ–≤
        const clock = new THREE.Clock();
    </script>
</body>
</html>
