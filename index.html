<!DOCTYPE html>
<html>
<head>
    <title>TeleCraft Pro</title>
    <style>
        /* Previous styles remain */
        .crafting-menu {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(32, 32, 32, 0.95);
            padding: 20px;
            border-radius: 12px;
            backdrop-filter: blur(10px);
            display: none;
            grid-template-columns: repeat(2, 1fr);
            gap: 15px;
            color: white;
        }
        .recipe {
            padding: 10px;
            border: 1px solid #3390ec;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.2s;
        }
        .recipe:hover {
            background: rgba(255, 255, 255, 0.1);
        }
        .inventory-count {
            position: absolute;
            bottom: 2px;
            right: 2px;
            font-size: 12px;
            color: white;
            text-shadow: 1px 1px 2px black;
        }
    </style>
</head>
<body>
    <!-- Previous HTML elements remain -->
    <div class="crafting-menu" id="crafting-menu"></div>

    <script>
        // Modified code with new features
        let inventory = {
            slots: Array(9).fill().map(() => ({ type: 0, count: 0 })),
            selectedSlot: 0
        };

        const CRAFT_RECIPES = {
            'planks': {
                requires: [{ type: 1, count: 1 }],
                gives: { type: 4, count: 4 },
                shape: [[1]]
            },
            'stick': {
                requires: [{ type: 4, count: 2 }],
                gives: { type: 5, count: 4 },
                shape: [[4], [4]]
            }
        };

        // Add new block types
        BLOCK_TYPES[4] = { name: 'Planks', color: '#8D6E63' };
        BLOCK_TYPES[5] = { name: 'Stick', color: '#A1887F' };

        function init() {
            // Previous init code
            inventory.slots[0] = { type: 1, count: 32 };
            initCraftingMenu();
        }

        function initHotbar() {
            const hotbar = document.getElementById('hotbar');
            hotbar.innerHTML = '';
            
            inventory.slots.forEach((slot, index) => {
                const slotDiv = document.createElement('div');
                slotDiv.className = `block-slot ${index === inventory.selectedSlot ? 'selected' : ''}`;
                if (slot.type !== 0) {
                    slotDiv.style.backgroundColor = BLOCK_TYPES[slot.type].color;
                    const count = document.createElement('div');
                    count.className = 'inventory-count';
                    count.textContent = slot.count;
                    slotDiv.appendChild(count);
                }
                
                slotDiv.onclick = () => selectSlot(index);
                hotbar.appendChild(slotDiv);
            });
        }

        function selectSlot(index) {
            inventory.selectedSlot = index;
            if (inventory.slots[index].type !== 0) {
                selectedBlock = inventory.slots[index].type;
                document.getElementById('selected-block').textContent = BLOCK_TYPES[selectedBlock].name;
            }
            initHotbar();
        }

        function onKeyDown(event) {
            // Previous key handling
            if (event.key >= '1' && event.key <= '9') {
                const slotIndex = parseInt(event.key) - 1;
                if (slotIndex < inventory.slots.length) {
                    selectSlot(slotIndex);
                }
            }
            if (event.key === 'e') {
                document.getElementById('crafting-menu').style.display = 'grid';
            }
        }

        function onKeyUp(event) {
            if (event.key === 'e') {
                document.getElementById('crafting-menu').style.display = 'none';
            }
        }

        function initCraftingMenu() {
            const menu = document.getElementById('crafting-menu');
            Object.entries(CRAFT_RECIPES).forEach(([name, recipe]) => {
                const recipeDiv = document.createElement('div');
                recipeDiv.className = 'recipe';
                recipeDiv.innerHTML = `
                    <div>${BLOCK_TYPES[recipe.gives.type].name} x${recipe.gives.count}</div>
                    <div>Requires: ${recipe.requires.map(r => `${BLOCK_TYPES[r.type].name} x${r.count}`).join(', ')}</div>
                `;
                recipeDiv.onclick = () => craftItem(name);
                menu.appendChild(recipeDiv);
            });
        }

        function craftItem(recipeName) {
            const recipe = CRAFT_RECIPES[recipeName];
            if (!hasMaterials(recipe.requires)) return;
            
            recipe.requires.forEach(required => {
                removeFromInventory(required.type, required.count);
            });
            addToInventory(recipe.gives.type, recipe.gives.count);
            initHotbar();
        }

        function hasMaterials(requirements) {
            return requirements.every(req => {
                const total = inventory.slots.reduce((sum, slot) => 
                    slot.type === req.type ? sum + slot.count : sum, 0);
                return total >= req.count;
            });
        }

        function addToInventory(type, count) {
            const existingSlot = inventory.slots.find(slot => 
                slot.type === type && slot.count < 64);
            
            if (existingSlot) {
                existingSlot.count += count;
            } else {
                const emptySlot = inventory.slots.findIndex(slot => slot.type === 0);
                if (emptySlot !== -1) {
                    inventory.slots[emptySlot] = { type, count };
                }
            }
        }

        function removeFromInventory(type, count) {
            let remaining = count;
            inventory.slots.forEach(slot => {
                if (slot.type === type && remaining > 0) {
                    const remove = Math.min(slot.count, remaining);
                    slot.count -= remove;
                    remaining -= remove;
                    if (slot.count === 0) slot.type = 0;
                }
            });
        }

        // Collision detection
        function checkCollisions(newPos) {
            const playerBox = new THREE.Box3(
                new THREE.Vector3(newPos.x - 0.3, newPos.y - 1.8, newPos.z - 0.3),
                new THREE.Vector3(newPos.x + 0.3, newPos.y + 0.1, newPos.z + 0.3)
            );

            return blocks.some(block => {
                const blockBox = new THREE.Box3(
                    new THREE.Vector3(block.position.x - 0.5, block.position.y - 0.5, block.position.z - 0.5),
                    new THREE.Vector3(block.position.x + 0.5, block.position.y + 0.5, block.position.z + 0.5)
                );
                return playerBox.intersectsBox(blockBox);
            });
        }

        // Modified movement system with collision
        function animate() {
            // Previous movement code
            const newPos = camera.position.clone().add(direction.multiplyScalar(speed));
            if (!checkCollisions(newPos)) {
                camera.position.copy(newPos);
            }
        }

        // Save/Load system
        function saveGame() {
            const saveData = {
                inventory: inventory,
                blocks: blocks.map(block => ({
                    type: block.userData.type,
                    x: block.position.x,
                    y: block.position.y,
                    z: block.position.z
                })),
                position: camera.position.toArray()
            };
            localStorage.setItem('telecraft-save', JSON.stringify(saveData));
        }

        function loadGame() {
            const saveData = JSON.parse(localStorage.getItem('telecraft-save'));
            if (saveData) {
                // Clear existing blocks
                blocks.forEach(block => scene.remove(block));
                blocks = [];
                
                // Load blocks
                saveData.blocks.forEach(blockData => {
                    addBlock(blockData.x, blockData.y, blockData.z, blockData.type);
                });

                // Load inventory
                inventory = saveData.inventory;
                initHotbar();

                // Load position
                camera.position.fromArray(saveData.position);
            }
        }

        // Add save/load keybindings
        window.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 's') {
                saveGame();
                e.preventDefault();
            }
            if (e.ctrlKey && e.key === 'l') {
                loadGame();
            }
        });
    </script>
</body>
</html>
